use solana_client::{
    rpc_client::RpcClient,
    rpc_config::{ RpcAccountInfoConfig, RpcProgramAccountsConfig },
    rpc_filter::{ RpcFilterType, MemcmpEncodedBytes, Memcmp },
};

use solana_sdk::{
    pubkey::Pubkey,
    system_instruction,
    commitment_config::{ CommitmentConfig, CommitmentLevel },
    signer::{
        keypair::Keypair,
        Signer,
    },
    signature::Signature,
    transaction::Transaction,
    borsh::try_from_slice_unchecked,
    program_pack::Pack
};

use solana_account_decoder::UiAccountEncoding;

use alloy_token_program::{
    instruction::NftInstruction,
    state::{AlloyData, PREFIX},
};

use spl_token::state::Mint;

use crate::cl_errors::CustomError;

pub const CLIENT_URL: String = "https://api.devnet.solana.com".to_string();
pub const WALLET_FILE_PATH: String = "wallet.keypair".to_string();

pub struct NftClient {
    client: RpcClient,
}


pub type AlloyResult<T> = Result<T, CustomError>;

impl NftClient {
    pub fn new() ->  AlloyResult<Self> {
        Ok(NftClient {
            client: RpcClient::new_with_commitment(
                CLIENT_URL,
                CommitmentConfig::confirmed()
            )
        })
    }

    pub fn create_mint_account(
        &self,
        mint_account: &Keypair,
        wallet_keypair: &Keypair,
    ) -> AlloyResult<Pubkey> {
        let mint_acc_pk = mint_account.pubkey();
        let wallet_pk = wallet_keypair.pubkey();

        let min_bal__for_rent_exempt = self.client
            .get_minimum_balance_for_rent_exemption(Mint::LEN)
            .unwrap();

        let create_account_instruction: Instruction = system_instruction::create_account(
            &wallet_pk,
            &mint_acc_pk,
            min_bal__for_rent_exempt,
            Mint::LEN as u64,
            &spl_token::id()
        );

        let initialize_mint_instruction:Instruction = spl_token::instruction::initialize_mint(
            &spl_token::id(),
            mint_acc_pk,
            &wallet_pk,
            None,
            0
        )
        .unwrap();

        let latest_blockhash = self.client.get_latest_blockhash().unwrap();

        let transaction: Transaction = Transaction::new_signed_with_payer(
            &vec![create_account_instruction, initialize_mint_instruction],
            Some(&wallet_pubkey),
            &[&mint_account, &wallet_keypair],
            recent_blockhash,
        );
    }
}

// fn create_mint_account(wallet_keypair: &Keypair, client: &RpcClient) -> Pubkey {
//     let mint_account: Keypair = Keypair::new();
//     let mint_account_pubkey = mint_account.pubkey();
//     let wallet_pubkey = wallet_keypair.pubkey();

//     let minimum_balance_for_rent_exemption = client
//         .get_minimum_balance_for_rent_exemption(Mint::LEN)
//         .unwrap();

//     let create_account_instruction: Instruction = solana_sdk::system_instruction::create_account(
//         &wallet_pubkey,
//         &mint_account_pubkey,
//         minimum_balance_for_rent_exemption,
//         Mint::LEN as u64,
//         &spl_token::id(),
//     );
//     let initialize_mint_instruction: Instruction = spl_token::instruction::initialize_mint(
//         &spl_token::id(),
//         &mint_account_pubkey,
//         &wallet_pubkey,
//         None,
//         0,
//     )
//     .unwrap();

//     let (recent_blockhash, _fee_calculator) = client.get_recent_blockhash().unwrap();

//     let transaction: Transaction = Transaction::new_signed_with_payer(
//         &vec![create_account_instruction, initialize_mint_instruction],
//         Some(&wallet_pubkey),
//         &[&mint_account, &wallet_keypair],
//         recent_blockhash,
//     );

//     let result = client.send_and_confirm_transaction_with_spinner(&transaction);

//     if result.is_ok() {
//         println!(
//             "Successfully created a Mint Account with Pubkey: {:?}",
//             mint_account_pubkey
//         )
//     };

//     return mint_account_pubkey;
// }